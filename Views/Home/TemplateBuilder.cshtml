@{
  ViewData["Title"] = "PDF Template Builder";
  Layout = "_Layout";
}

<div class="container py-4" id="template-builder-root"></div>

<style>
  .tb-row {
    display: grid;
    gap: 12px;
  }

  .tb-row-regular {
    grid-template-columns: 1fr 1fr;
  }

  .tb-row-expanded {
    grid-template-columns: 1fr;
  }

  .tb-preview {
    position: relative;
    border: 1px dashed rgba(71, 71, 71, 0.5);
    border-radius: 10px;
    overflow: hidden;
  }

  .tb-page {
    position: relative;
    margin-bottom: 12px;
  }

  .tb-overlay {
    position: absolute;
    inset: 0;
  }

  .tb-field {
    position: absolute;
    background: rgba(55, 55, 55, 0.8);
    color: #e2e8f0;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    user-select: none;
  }

  .tb-chip {
    border: 1px dashed rgba(0, 0, 0, 0.5);
    border-radius: 8px;
    padding: 1rem;
    display: flex;
    align-items: center;
    gap: 6px;
    width: 100%;
    margin-bottom: 1rem;
  }

  .tb-error {
    font-size: 0.95rem;
  }

  input,
  select,
  button,
  textarea {
    border-radius: 8px !important;
  }
</style>

<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin></script>
<script src="https://unpkg.com/@@babel/standalone/babel.min.js" crossorigin></script>

<script type="text/babel" data-presets="env,react">
  const { useEffect, useRef, useState } = React;
  const createRoot = ReactDOM.createRoot;
  const aiDetectEnabled = @(ViewData["AiDetectEnabled"] is true ? "true" : "false");

  if (window.pdfjsLib) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  }

  const fieldDefaults = {
    type: "text",
    fontSize: 12,
    fontName: "Helvetica",
    fontWeight: "normal",
    horizontalAlign: "left",
    verticalAlign: "center",
    barcodeFormat: "code128",
    columns: 0,
    tableColumns: []
  };
  const allowedFonts = ["Helvetica", "Times-Roman", "Courier", "Symbol", "ZapfDingbats"];
  const fontWeights = ["tiny", "normal", "bold"];
  const fontSizes = Array.from({ length: 124 }, (_, i) => i + 5); // 5..128

  function toBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function loadPdfPages(base64) {
    const raw = atob(base64);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
    return window.pdfjsLib.getDocument({ data: bytes }).promise;
  }

  function TemplateBuilderApp() {
    const [pdfBase64, setPdfBase64] = useState("");
    const [pages, setPages] = useState([]);
    const [fields, setFields] = useState([]);
    const [currentPage, setCurrentPage] = useState(1);
    const [status, setStatus] = useState("");
    const [loading, setLoading] = useState(false);
    const [templateId, setTemplateId] = useState(null);
    const [templateName, setTemplateName] = useState("Template");
    const [dragState, setDragState] = useState(null); // { id, mode, startX, startY, startLeftPx, startTopPx, startWidthPx, startHeightPx, scaleX, scaleY, page, pdfRect }
    const [previewExpanded, setPreviewExpanded] = useState(false);
    const [overlaySizes, setOverlaySizes] = useState({});
    const [expandedFieldId, setExpandedFieldId] = useState(null);
    const [dirty, setDirty] = useState(false);
    const [aiBusy, setAiBusy] = useState(false);
    const chipsRef = useRef(null);
    const overlayRefs = useRef({});

    useEffect(() => {
      if (!pdfBase64) {
        setPages([]);
        return;
      }
      let cancelled = false;
      (async () => {
        try {
          const doc = await loadPdfPages(pdfBase64);
          const rendered = [];
          for (let i = 1; i <= doc.numPages; i++) {
            const page = await doc.getPage(i);
            // Use scale 1 so stored coordinates match PDF units (no scaling).
            const viewport = page.getViewport({ scale: 1 });
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: ctx, viewport }).promise;
            rendered.push({
              pageNumber: i,
              width: viewport.width,
              height: viewport.height,
              dataUrl: canvas.toDataURL("image/png")
            });
          }
          if (!cancelled) setPages(rendered);
        } catch (err) {
          console.error(err);
          setStatus("Failed to render PDF preview.");
        }
      })();
      return () => { cancelled = true; };
    }, [pdfBase64]);

    const addFieldToPage = () => {
      const page = pages.find(p => p.pageNumber === currentPage);
      if (!page) { setStatus("Upload a PDF first."); return; }
      const defaultWidth = page.width * 0.25;
      const defaultHeight = page.height * 0.07;
      const newField = {
        id: crypto.randomUUID(),
        fieldName: `Field_${fields.length + 1}`,
        page: currentPage,
        rect: {
          x: (page.width - defaultWidth) / 2,
          y: (page.height - defaultHeight) / 2,
          width: defaultWidth,
          height: defaultHeight
        },
        ...fieldDefaults
      };
      setFields([...fields, newField]);
      setStatus("");
    };

    const detectFieldsWithAi = async () => {
      if (!aiDetectEnabled) return;
      if (!pdfBase64) { setStatus("Upload a PDF first."); return; }
      setAiBusy(true);
      setStatus("Detecting fields with AI...");
      try {
        const res = await fetch("/api/ai/detect-fields", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify({
            pdfContent: pdfBase64,
            prompt: "Detect form fields for this PDF and return JSON with fieldName, page, rect (x,y,width,height in PDF points from bottom-left), and type."
          })
        });
        if (!res.ok) {
          const msg = await res.text();
          throw new Error(msg || "AI detection failed.");
        }
        const json = await res.json();
        const aiFields = (json.fields || []).map((f, idx) => ({
          id: crypto.randomUUID(),
          fieldName: f.fieldName || `AI_Field_${fields.length + idx + 1}`,
          page: f.page || 1,
          rect: {
            x: f.rect?.x ?? 0,
            y: f.rect?.y ?? 0,
            width: f.rect?.width ?? 120,
            height: f.rect?.height ?? 32
          },
          fontSize: f.fontSize || fieldDefaults.fontSize,
          fontName: f.fontName || fieldDefaults.fontName,
          fontWeight: f.fontWeight || fieldDefaults.fontWeight,
          type: f.type || fieldDefaults.type,
          barcodeFormat: f.barcodeFormat || fieldDefaults.barcodeFormat,
          horizontalAlign: f.horizontalAlign || fieldDefaults.horizontalAlign,
          verticalAlign: f.verticalAlign || fieldDefaults.verticalAlign,
          columns: f.columns || 0,
          tableColumns: f.tableColumns || []
        }));

        if (aiFields.length === 0) {
          setStatus("AI did not return any fields.");
          return;
        }

        setFields([...fields, ...aiFields]);
        setStatus(`AI added ${aiFields.length} field${aiFields.length === 1 ? "" : "s"}.`);
        setDirty(true);
      } catch (err) {
        console.error(err);
        setStatus(err.message || "AI detection failed.");
      } finally {
        setAiBusy(false);
      }
    };

    const updateField = (id, patch) => setFields(fields.map(f => f.id === id ? { ...f, ...patch } : f));
    const nudgeFieldByPixels = (fieldId, dxPx, dyPx, scaleX, scaleY, pageSize) => {
      setFields(prev => prev.map(f => {
        if (f.id !== fieldId) return f;
        const deltaX = dxPx / (scaleX || 1);
        const deltaY = -dyPx / (scaleY || 1);
        const nextX = Math.min(Math.max(0, f.rect.x + deltaX), (pageSize?.width || f.rect.width) - f.rect.width);
        const nextY = Math.min(Math.max(0, f.rect.y + deltaY), (pageSize?.height || f.rect.height) - f.rect.height);
        return { ...f, rect: { ...f.rect, x: nextX, y: nextY } };
      }));
      setDirty(true);
    };
    const startDrag = (field, mode, clientX, clientY, scaled) => {
      setDragState({
        id: field.id,
        mode,
        startX: clientX,
        startY: clientY,
        startLeftPx: scaled.x,
        startTopPx: scaled.y,
        startWidthPx: scaled.w,
        startHeightPx: scaled.h,
        scaleX: scaled.scaleX,
        scaleY: scaled.scaleY,
        page: field.page,
        pdfRect: { ...field.rect }
      });
    };

    const handleMouseMove = (e) => {
      if (!dragState) return;
      const page = pages.find(p => p.pageNumber === dragState.page);
      const overlay = overlayRefs.current[dragState.page];
      if (!page || !overlay) return;
      const dxPx = e.clientX - dragState.startX;
      const dyPx = e.clientY - dragState.startY;

      setFields(fields.map(f => {
        if (f.id !== dragState.id) return f;

        if (dragState.mode === "move") {
          const newLeftPx = dragState.startLeftPx + dxPx;
          const newTopPx = dragState.startTopPx + dyPx;
          const pdfX = newLeftPx / dragState.scaleX;
          const pdfY = page.height - (newTopPx / dragState.scaleY) - dragState.pdfRect.height;
          return { ...f, rect: { ...f.rect, x: pdfX, y: pdfY } };
        }

        const newWidthPx = Math.max(25, dragState.startWidthPx + dxPx);
        const newHeightPx = Math.max(15, dragState.startHeightPx + dyPx);
        const pdfWidth = newWidthPx / dragState.scaleX;
        const pdfHeight = newHeightPx / dragState.scaleY;
        const pdfX = dragState.pdfRect.x;
        const pdfY = page.height - (dragState.startTopPx / dragState.scaleY) - pdfHeight;
        return { ...f, rect: { ...f.rect, x: pdfX, y: pdfY, width: pdfWidth, height: pdfHeight } };
      }));
    };

    const handleMouseUp = () => {
      if (dragState) setDragState(null);
    };
    const removeField = id => { setFields(fields.filter(f => f.id !== id)); setDirty(true); };
    const removeFieldWithConfirm = (id) => {
      if (confirm("Remove this field?")) {
        removeField(id);
        if (expandedFieldId === id) setExpandedFieldId(null);
      }
    };

    const handleFile = async (file) => {
      setStatus("Reading PDF...");
      const b64 = await toBase64(file);
      setPdfBase64(b64);
      setFields([]);
      setCurrentPage(1);
      setStatus("");
      setDirty(true);
    };

    const saveTemplate = async () => {
      if (!pdfBase64) { setStatus("Upload a PDF first."); return; }
      if (!fields.length) { setStatus("Add at least one field."); return; }
      const badName = fields.find(f => !/^[A-Za-z0-9_-]+$/.test(f.fieldName || ""));
      if (badName) { setStatus("Field names may only contain letters, numbers, underscore or dash."); return; }
      setLoading(true);
      setStatus("Saving template...");
      try {
        const payload = {
          pdfContent: pdfBase64,
          fields: fields.map(f => ({
            fieldName: f.fieldName,
            rect: f.rect,
            page: f.page,
            fontSize: f.fontSize,
            fontName: f.fontName,
            fontWeight: f.fontWeight,
            type: f.type,
            barcodeFormat: f.barcodeFormat,
            horizontalAlign: f.horizontalAlign,
            verticalAlign: f.verticalAlign,
            columns: f.columns,
            tableColumns: f.tableColumns
          })),
          templateName
        };
        const res = await fetch(templateId ? `/api/pdf-template/${templateId}` : "/api/pdf-template", {
          method: templateId ? "PUT" : "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "include",
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          const msg = await res.text();
          throw new Error(msg || "Failed to save template.");
        }
        const json = await res.json();
        setTemplateId(json.templateId);
        setStatus(`Template saved successfully`);
        setDirty(false);
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Failed to save template.");
      } finally {
        setLoading(false);
      }
    };

    useEffect(() => {
      const params = new URLSearchParams(window.location.search);
      const tid = params.get("templateId");
      if (!tid) return;
      (async () => {
        try {
          setStatus("Loading template...");
          const res = await fetch(`/api/pdf-template/${tid}`, { credentials: "include" });
          if (!res.ok) throw new Error(await res.text());
          const json = await res.json();
          setTemplateId(json.templateId);
          setTemplateName(json.name || "Template");
          setPdfBase64(json.pdfContent);
          const normalizedFields = (json.fields || []).map((f, idx) => ({
            id: crypto.randomUUID(),
            fieldName: f.fieldName || `Field_${idx + 1}`,
            rect: f.rect,
            page: f.page || 1,
            fontSize: f.fontSize || 12,
            fontName: f.fontName || "Helvetica",
            fontWeight: f.fontWeight || "normal",
            type: f.type || "text",
            barcodeFormat: f.barcodeFormat || "code128",
            horizontalAlign: f.horizontalAlign || "left",
            verticalAlign: f.verticalAlign || "center",
            columns: f.columns || f.tableColumns?.length || 0,
            tableColumns: (f.tableColumns || []).map((c, i) => ({
              name: c.name || `Col ${i + 1}`,
              widthPercent: c.widthPercent ?? (100 / Math.max(1, f.tableColumns?.length || 1)),
              fontSize: c.fontSize || 12,
              fontWeight: c.fontWeight || "normal",
              borderStyle: c.borderStyle || (f.tableColumns?.[0]?.borderStyle) || "none",
              horizontalAlign: c.horizontalAlign || "left",
              verticalAlign: c.verticalAlign || "center"
            }))
          }));
          setFields(normalizedFields);
          setCurrentPage(normalizedFields[0]?.page || 1);
          setStatus("");
        } catch (e) {
          console.error(e);
          setStatus(e.message || "Failed to load template.");
        }
      })();
    }, []);

    const recomputeOverlaySizes = () => {
      const next = {};
      pages.forEach(p => {
        const el = overlayRefs.current[p.pageNumber];
        if (!el) return;
        next[p.pageNumber] = { width: el.clientWidth, height: el.clientHeight };
      });
      if (Object.keys(next).length > 0) {
        setOverlaySizes(next);
      }
    };

    useEffect(() => {
      recomputeOverlaySizes();
    }, [pages, previewExpanded]);

    useEffect(() => {
      const handler = () => recomputeOverlaySizes();
      window.addEventListener("resize", handler);
      return () => window.removeEventListener("resize", handler);
    }, [pages]);

    useEffect(() => {
      const handler = (e) => {
        if (!chipsRef.current) return;
        if (!chipsRef.current.contains(e.target)) {
          setExpandedFieldId(null);
        }
      };
      document.addEventListener("mousedown", handler);
      @* const keyHandler = (e) => {
        if (expandedFieldId && (e.key === "Delete" || e.key === "Backspace")) {
          e.preventDefault();
          removeFieldWithConfirm(expandedFieldId);
        }
      };
      window.addEventListener("keydown", keyHandler); *@
      const beforeUnload = (event) => {
        if (dirty) {
          event.preventDefault();
          event.returnValue = "";
        }
      };
      window.addEventListener("beforeunload", beforeUnload);
      return () => {
        document.removeEventListener("mousedown", handler);
        @* window.removeEventListener("keydown", keyHandler); *@
          window.removeEventListener("beforeunload", beforeUnload);
      };
    }, [dirty]);

    const calculateNewTableColumns = (field) => {
      const existing = field.tableColumns || [];
      const borderStyle = existing[0]?.borderStyle || "none";
      const hAlign = existing[0]?.horizontalAlign || "left";
      const vAlign = existing[0]?.verticalAlign || "center";
      const round2 = (val) => Math.round((Number(val) || 0) * 100) / 100;
      if (existing.length === 0) {
        return [{ name: "Col 1", widthPercent: 100, fontSize: 12, fontWeight: "normal", borderStyle, horizontalAlign: hAlign, verticalAlign: vAlign }];
      }

      const currentSum = existing.reduce((sum, col) => sum + (Number(col.widthPercent) || 0), 0);
      const newIndex = existing.length + 1;
      const nextCols = [];

      if (Math.abs(currentSum - 100) < 0.01 || currentSum >= 100) {
        // Sum is 100 (or above): shrink existing proportionally and give the new column an even share.
        const newWidth = 100 / newIndex;
        const scale = currentSum === 0 ? 0 : (100 - newWidth) / currentSum;
        existing.forEach((col) => {
          nextCols.push({ ...col, widthPercent: round2((Number(col.widthPercent) || 0) * scale) });
        });
        nextCols.push({ name: `Col ${newIndex}`, widthPercent: round2(newWidth), fontSize: 12, fontWeight: "normal", borderStyle, horizontalAlign: hAlign, verticalAlign: vAlign });
      } else {
        // Sum is under 100: assign the missing difference to the new column.
        const diff = 100 - currentSum;
        existing.forEach((col) => nextCols.push({ ...col }));
        nextCols.push({ name: `Col ${newIndex}`, widthPercent: round2(diff), fontSize: 12, fontWeight: "normal", borderStyle, horizontalAlign: hAlign, verticalAlign: vAlign });
      }

      // Normalize tiny rounding errors onto the last column to keep the total at 100%.
      const total = nextCols.reduce((sum, col) => sum + (Number(col.widthPercent) || 0), 0);
      const delta = round2(100 - total);
      if (Math.abs(delta) >= 0.01) {
        const lastIdx = nextCols.length - 1;
        nextCols[lastIdx] = { ...nextCols[lastIdx], widthPercent: round2((Number(nextCols[lastIdx].widthPercent) || 0) + delta) };
      }

      return nextCols;
    };

    return (
      <>
        @* <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}> *@
        <div className="flex justify-between items-center mb-4">
          <h1 className="content-box-title">{templateId ? "Edit PDF Template" : "Create PDF Template"}</h1>
          <a className="btn btn-primary" href="/templates">Back to list</a>
        </div>
        <div className="card">
          <div className={`tb-row ${previewExpanded ? "tb-row-expanded" : "tb-row-regular"}`}>
            {!previewExpanded && (
              <div>
                {templateId === null && (
                  <div className="form-group">
                    <label className="form-label muted">Upload PDF</label>
                    <input className="form-input mb-3" type="file" accept="application/pdf" onChange={e => e.target.files?.[0] && handleFile(e.target.files[0])} />
                  </div>
                )}
                <div className="form-group">
                  <label className="form-label muted">Template name</label>
                  <input className="form-input mb-3" type="text" value={templateName} onChange={e => setTemplateName(e.target.value)} />
                </div>


                <button className={`full-w mb-4 btn btn-primary${loading || !pdfBase64 || !templateName || fields.length === 0 ? " btn-disabled" : ""}`} onClick={saveTemplate} disabled={loading || !pdfBase64 || !templateName || fields.length === 0}>
                  {loading ? "Saving..." : "Save Template"}
                </button>

                {status && <div className="tb-error mt-2 mb-4">{status}</div>}

                {fields.length === 0 && <p className="muted mb-2">No fields yet. Click "Add field" for the current page.</p>}
                <div className="flex flex-col gap-2">
                  {fields.map(f => (
                    <div key={f.id} className="card">
                      <div className="flex flex-col gap-2 items-center full-w">
                        <div className="flex items-center justify-between full-w">
                          <div className="flex-grow-1" onClick={() => {
                            if (f.page !== currentPage) setCurrentPage(f.page);
                            setExpandedFieldId(expandedFieldId === f.id ? null : f.id)
                          }} style={{ cursor: 'pointer' }}>
                            <strong>{f.fieldName}</strong><br />
                            <small>Page {f.page} • {f.type}{f.type === "barcode" && f.barcodeFormat ? ` • ${f.barcodeFormat}` : ""}</small>
                          </div>
                          <button className="btn btn-danger btn-small" onClick={() => removeFieldWithConfirm(f.id)}>×</button>
                        </div>
                        {expandedFieldId === f.id && (
                          <div className="flex flex-col gap-2 full-w mt-2">
                            <div className="form-group form-group-sm">
                              <label htmlFor={`fieldName-${f.id}`} className="form-label form-label-sm">Field Name:</label>
                              <input
                                id={`fieldName-${f.id}`}
                                className="form-input form-input-sm"
                                value={f.fieldName}
                                onChange={e => {
                                  const val = e.target.value;
                                  if (!/^[A-Za-z0-9_-]*$/.test(val)) return;
                                  updateField(f.id, { fieldName: val });
                                  setDirty(true);
                                }} />
                            </div>
                            <div className="form-group form-group-sm">
                              <label htmlFor={`fieldType-${f.id}`} className="form-label form-label-sm">Type:</label>
                              <select id={`fieldType-${f.id}`} className="form-input form-input-sm" value={f.type} onChange={e => {
                                const newType = e.target.value;
                                const patch = { type: newType };
                                if (newType === "table" && (!f.tableColumns || f.tableColumns.length === 0)) {
                                  patch.tableColumns = [{ name: "Col 1", widthPercent: 100, fontSize: 12, fontWeight: "normal", borderStyle: "none", horizontalAlign: "left", verticalAlign: "center" }];
                                  patch.columns = 1;
                                }
                                updateField(f.id, patch);
                                setDirty(true);
                              }}>
                                <option value="text">Text</option>
                                <option value="image">Image</option>
                                <option value="barcode">Barcode</option>
                                <option value="signature">Signature</option>
                                <option value="table">Table</option>
                              </select>
                            </div>
                            {f.type === "barcode" && (
                              <div className="form-group form-group-sm">
                                <label htmlFor={`barcodeFormat-${f.id}`} className="form-label form-label-sm">Barcode Format:</label>
                                <select id={`barcodeFormat-${f.id}`} className="form-input form-input-sm" value={f.barcodeFormat} onChange={e => updateField(f.id, { barcodeFormat: e.target.value })}>
                                  <option value="qrcode">QR</option>
                                  <option value="datamatrix">DataMatrix</option>
                                  <option value="pdf417">PDF417</option>
                                  <option value="code128">Code128</option>
                                  <option value="code39">Code39</option>
                                  <option value="ean13">EAN13</option>
                                  <option value="ean8">EAN8</option>
                                  <option value="upca">UPC-A</option>
                                  <option value="itf">ITF</option>
                                </select>
                              </div>
                            )}
                            {f.type === "text" && (
                              <span className="flex gap-1 justify-between">
                                <div className="form-group form-group-sm">
                                  <label htmlFor={`fontName-${f.id}`} className="form-label form-label-sm">Font:</label>
                                  <select id={`fontName-${f.id}`} className="form-input form-input-sm" value={f.fontName} onChange={e => { updateField(f.id, { fontName: e.target.value }); setDirty(true); }}>
                                    {allowedFonts.map(fn => <option key={fn} value={fn}>{fn}</option>)}
                                  </select>
                                </div>
                                <div className="form-group form-group-sm">
                                  <label htmlFor={`fontSize-${f.id}`} className="form-label form-label-sm">Size:</label>
                                  <select id={`fontSize-${f.id}`} className="form-input form-input-sm" value={f.fontSize} onChange={e => { updateField(f.id, { fontSize: Number(e.target.value) }); setDirty(true); }}>
                                    {fontSizes.map(sz => <option key={sz} value={sz}>{sz}px</option>)}
                                  </select>
                                </div>
                                <div className="form-group form-group-sm">
                                  <label htmlFor={`fontWeight-${f.id}`} className="form-label form-label-sm">Weight:</label>
                                  <select id={`fontWeight-${f.id}`} className="form-input form-input-sm" value={f.fontWeight} onChange={e => { updateField(f.id, { fontWeight: e.target.value }); setDirty(true); }}>
                                    {fontWeights.map(w => <option key={w} value={w}>{w}</option>)}
                                  </select>
                                </div>
                                <div className="form-group form-group-sm">
                                  <label className="form-label form-label-sm">Horizontal:</label>
                                  <select className="form-input form-input-sm" value={f.horizontalAlign || "left"} onChange={e => { updateField(f.id, { horizontalAlign: e.target.value }); setDirty(true); }}>
                                    <option value="left">Left</option>
                                    <option value="center">Center</option>
                                    <option value="right">Right</option>
                                  </select>
                                </div>
                                <div className="form-group form-group-sm">
                                  <label className="form-label form-label-sm">Vertical:</label>
                                  <select className="form-input form-input-sm" value={f.verticalAlign || "center"} onChange={e => { updateField(f.id, { verticalAlign: e.target.value }); setDirty(true); }}>
                                    <option value="top">Top</option>
                                    <option value="center">Center</option>
                                    <option value="bottom">Bottom</option>
                                  </select>
                                </div>
                              </span>
                            )}
                            {f.type === "table" && (
                              <div className="flex gap-1 flex-col">
                                <div className="form-group form-group-sm">
                                  <label className="form-label form-label-sm">Font:</label>
                                  <select className="form-input form-input-sm" value={f.fontName} onChange={e => { updateField(f.id, { fontName: e.target.value }); setDirty(true); }}>
                                    {allowedFonts.map(fn => <option key={fn} value={fn}>{fn}</option>)}
                                  </select>
                                </div>
                                <div className="flex-grow-1">
                                  <label className="form-label form-label-sm">Border:</label>
                                  <select className="form-input form-input-sm" value={(f.tableColumns?.[0]?.borderStyle) || "none"} onChange={e => {
                                    let next = [...(f.tableColumns || [])].map(col => ({ ...col, borderStyle: e.target.value }));
                                    if (next.length === 0) {
                                      next = [{ name: "Col 1", widthPercent: 100, fontSize: 12, fontWeight: "normal", borderStyle: e.target.value, horizontalAlign: "left", verticalAlign: "center" }];
                                    }
                                    updateField(f.id, { tableColumns: next, columns: next.length });
                                    setDirty(true);
                                  }}>
                                    <option value="none">No border</option>
                                    <option value="dashed">Dashed</option>
                                    <option value="filled">Filled</option>
                                  </select>
                                </div>

                                <div class="flex flex-col gap-2">
                                  <strong className="mt-2 mb-1">Columns</strong>
                                  {(f.tableColumns || []).map((c, idx) => (
                                    <div key={idx} className="card card-sm">
                                      <div className="flex justify-between items-center mb-1">
                                        <span>Column {idx + 1}</span>
                                        <button className="btn btn-small btn-danger" onClick={() => {
                                          const current = f.tableColumns || [];
                                          if (current.length <= 1) return;
                                          const next = [...current];
                                          next.splice(idx, 1);
                                          updateField(f.id, { tableColumns: next, columns: next.length });
                                          setDirty(true);
                                        }}>×</button>
                                      </div>
                                      <div className="form-group form-group-sm">
                                        <label className="form-label form-label-sm">Column name:</label>
                                        <input type="text" className="form-input form-input-sm" placeholder="Name" value={c.name || ""} onChange={e => {
                                          const next = [...(f.tableColumns || [])];
                                          next[idx] = { ...next[idx], name: e.target.value };
                                          updateField(f.id, { tableColumns: next, columns: next.length });
                                          setDirty(true);
                                        }} />
                                      </div>
                                      <div className="form-group form-group-sm">
                                        <label className="form-label form-label-sm">Column width (%):</label>
                                        <input
                                          type="number"
                                          min="1"
                                          max="100"
                                          required
                                          className="form-input form-input-sm"
                                          placeholder="Width %"
                                          value={c.widthPercent ?? 100}
                                          onChange={e => {
                                            const next = [...(f.tableColumns || [])];
                                            const raw = Number(e.target.value);
                                            const val = Number.isFinite(raw) ? Math.min(100, Math.max(1, raw)) : 1;
                                            next[idx] = { ...next[idx], widthPercent: val };
                                            updateField(f.id, { tableColumns: next, columns: next.length });
                                            setDirty(true);
                                          }}
                                        />
                                      </div>
                                      <div className="form-group form-group-sm">
                                        <label className="form-label form-label-sm">Column font size:</label>
                                        <select className="form-input form-input-sm" value={c.fontSize} onChange={e => {
                                          const next = [...(f.tableColumns || [])];
                                          next[idx] = { ...next[idx], fontSize: Number(e.target.value) };
                                          updateField(f.id, { tableColumns: next, columns: next.length });
                                          setDirty(true);
                                        }}>
                                          {fontSizes.map(sz => <option key={sz} value={sz}>{sz}px</option>)}
                                        </select>
                                      </div>
                                      <div className="form-group form-group-sm">
                                        <label className="form-label form-label-sm">Column font weight:</label>
                                        <select className="form-input form-input-sm" value={c.fontWeight} onChange={e => {
                                          const next = [...(f.tableColumns || [])];
                                          next[idx] = { ...next[idx], fontWeight: e.target.value };
                                          updateField(f.id, { tableColumns: next, columns: next.length });
                                          setDirty(true);
                                        }}>
                                          {fontWeights.map(w => <option key={w} value={w}>{w}</option>)}
                                        </select>
                                      </div>
                                      <div className="form-group form-group-sm">
                                        <label className="form-label form-label-sm">Column horizontal alignment:</label>
                                        <select className="form-input form-input-sm" value={c.horizontalAlign || "left"} onChange={e => {
                                          const next = [...(f.tableColumns || [])];
                                          next[idx] = { ...next[idx], horizontalAlign: e.target.value };
                                          updateField(f.id, { tableColumns: next, columns: next.length });
                                          setDirty(true);
                                        }}>
                                          <option value="left">Left</option>
                                          <option value="center">Center</option>
                                          <option value="right">Right</option>
                                        </select>
                                      </div>
                                      <div className="form-group form-group-sm">
                                        <label className="form-label form-label-sm">Column vertical alignment:</label>
                                        <select className="form-input form-input-sm" value={c.verticalAlign || "center"} onChange={e => {
                                          const next = [...(f.tableColumns || [])];
                                          next[idx] = { ...next[idx], verticalAlign: e.target.value };
                                          updateField(f.id, { tableColumns: next, columns: next.length });
                                          setDirty(true);
                                        }}>
                                          <option value="top">Top</option>
                                          <option value="center">Center</option>
                                          <option value="bottom">Bottom</option>
                                        </select>
                                      </div>
                                    </div>
                                  ))}
                                  <button className="btn btn-small" onClick={() => {
                                    const next = calculateNewTableColumns(f);
                                    updateField(f.id, { tableColumns: next, columns: next.length });
                                    setDirty(true);
                                  }}>Add column</button>
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
            <div>

              {pages.length > 0 && (
                <div className="flex gap-1 mb-1 justify-between">
                  <button className="btn btn-primary btn-small" onClick={addFieldToPage}>Add field</button>
                  {aiDetectEnabled && (
                    <button
                      className="btn btn-secondary btn-small"
                      disabled={aiBusy || !pdfBase64}
                      onClick={detectFieldsWithAi}
                    >
                      {aiBusy ? "Detecting..." : "AI detect fields"}
                    </button>
                  )}
                  <button className="btn btn-secondary btn-small" onClick={() => { setPreviewExpanded(!previewExpanded); }}>
                    {previewExpanded ? "Collapse" : "Expand"}
                  </button>

                </div>
              )}

              <div className="tb-preview">
                {pages.length === 0 && <p className="muted p-4 text-center">Upload a PDF to see a preview.</p>}
                {pages.filter(p => p.pageNumber === currentPage).map(p => (
                  <div key={p.pageNumber} className="tb-page">
                    <img
                      src={p.dataUrl}
                      alt={`Page ${p.pageNumber}`}
                      style={{ width: "100%", display: "block" }}
                      onLoad={() => {
                        const el = overlayRefs.current[p.pageNumber];
                        if (el) {
                          setOverlaySizes(prev => ({ ...prev, [p.pageNumber]: { width: el.clientWidth, height: el.clientHeight } }));
                        }
                      }}
                    />
                    <div
                      className="tb-overlay"
                      ref={el => overlayRefs.current[p.pageNumber] = el}
                      onMouseMove={handleMouseMove}
                      onMouseUp={handleMouseUp}
                      onMouseLeave={handleMouseUp}
                    >
                      {fields.filter(f => f.page === p.pageNumber).map(f => {
                        const size = overlaySizes[p.pageNumber]
                          || { width: overlayRefs.current[p.pageNumber]?.clientWidth || p.width, height: overlayRefs.current[p.pageNumber]?.clientHeight || p.height };
                        const scaleX = size.width / p.width;
                        const scaleY = size.height / p.height;
                        const x = f.rect.x * scaleX;
                        const y = (p.height - f.rect.y - f.rect.height) * scaleY;
                        const w = f.rect.width * scaleX;
                        const h = f.rect.height * scaleY;
                        const weight = f.fontWeight === "bold" ? 700 : f.fontWeight === "tiny" ? 300 : 400;
                        const fontPx = (f.fontSize || 12) * scaleY;
                        const horiz = f.horizontalAlign || "left";
                        const vert = f.verticalAlign || "center";
                        const justifyContent = horiz === "center" ? "center" : horiz === "right" ? "flex-end" : "flex-start";
                        const alignItems = vert === "top" ? "flex-start" : vert === "bottom" ? "flex-end" : "center";
                        return (
                          <div
                            key={f.id}
                            className="tb-field"
                            tabIndex={0}
                            onKeyDown={e => {
                              if ((e.key === "Delete" || e.key === "Backspace") && expandedFieldId === f.id) {
                                e.preventDefault();
                                removeFieldWithConfirm(f.id);
                              }
                              if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                                e.preventDefault();
                                const dx = e.key === "ArrowLeft" ? -1 : e.key === "ArrowRight" ? 1 : 0;
                                const dy = e.key === "ArrowUp" ? -1 : e.key === "ArrowDown" ? 1 : 0;
                                nudgeFieldByPixels(f.id, dx, dy, scaleX, scaleY, { width: p.width, height: p.height });
                              }
                            }}
                            style={{ left: x, top: y, width: w, height: h, background: expandedFieldId === f.id ? "rgba(75, 85, 99, 0.9)" : "rgba(55, 55, 55, 0.8)" }}>
                            <button
                              type="button"
                              style={{ position: "absolute", left: -10, top: -10, zIndex: 4 }}
                              class="btn btn-primary btn-template-builder-field"
                              onClick={() => {
                                setExpandedFieldId(expandedFieldId === f.id ? null : f.id);
                              }}
                            >
                              {expandedFieldId === f.id ? 'Done' : 'Edit'}
                            </button>
                            <div
                              style={{ position: "absolute", inset: 0, cursor: "move", zIndex: 3 }}
                              onMouseDown={e => { e.preventDefault(); startDrag(f, "move", e.clientX, e.clientY, { x, y, w, h, scaleX, scaleY }); }}
                            ></div>
                            <div
                              style={{ position: "absolute", right: -3, bottom: -3, width: 6, height: 6, cursor: "nwse-resize", background: "#2563eb", borderRadius: 4, zIndex: 5 }}
                              onMouseDown={e => { e.preventDefault(); startDrag(f, "resize", e.clientX, e.clientY, { x, y, w, h, scaleX, scaleY }); }}
                            ></div>
                            <div style={{ position: "relative", zIndex: 2, width: "100%", height: "100%", display: "flex", alignItems: f.type === "table" ? "stretch" : alignItems, justifyContent: f.type === "table" ? "stretch" : justifyContent, padding: f.type === 'table' ? 0 : "6px", pointerEvents: "none", fontFamily: f.fontName || "Helvetica, Arial, sans-serif" }}>
                              {f.type === "table" ? (
                                <div style={{ display: "flex", width: "100%", height: "100%" }}>
                                  {(f.tableColumns && f.tableColumns.length ? f.tableColumns : [{ name: "table example", widthPercent: 100, fontSize: 12, fontWeight: "normal", borderStyle: "none", horizontalAlign: "left", verticalAlign: "center" }]).map((col, idx) => {
                                    const colWidth = `${Math.max(1, Math.min(100, col.widthPercent ?? 100))}%`;
                                    const colWeight = col.fontWeight === "bold" ? 700 : col.fontWeight === "tiny" ? 300 : 400;
                                    const colFont = Math.max(6, (col.fontSize || 12) * scaleY);
                                    const colHoriz = col.horizontalAlign || "left";
                                    const colVert = col.verticalAlign || "center";
                                    const colJustify = colHoriz === "center" ? "center" : colHoriz === "right" ? "flex-end" : "flex-start";
                                    const colAlign = colVert === "top" ? "flex-start" : colVert === "bottom" ? "flex-end" : "center";
                                    let border = "none";
                                    let background = "transparent";
                                    if (col.borderStyle === "dashed") {
                                      border = "2px dashed rgba(0,0,0,0.8)";
                                    } else if (col.borderStyle === "filled") {
                                      border = "2px solid rgba(0,0,0,0.9)";
                                      background = "rgba(255,255,255,0.15)";
                                    }
                                    return (
                                      <div key={idx} style={{ flexBasis: colWidth, border, background, display: "flex", alignItems: colAlign, justifyContent: colJustify, padding: "2px" }}>
                                        <span style={{ fontSize: `${colFont}px`, fontWeight: colWeight, color: "#fff", textAlign: colHoriz === "center" ? "center" : colHoriz === "right" ? "right" : "left" }}>
                                          {col.name || "table example"}
                                        </span>
                                      </div>
                                    );
                                  })}
                                </div>
                              ) : (
                                <div style={{ fontSize: `${fontPx}px`, fontWeight: weight, lineHeight: 1, textAlign: "center" }}>
                                  {f.fieldName}
                                </div>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
              {pages.length > 0 && (
                <div className="d-grid" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: 12 }}>
                  <button
                    className={`btn btn-primary btn-small ${currentPage === 1 ? "btn-disabled" : ""}`}
                    onClick={() => {
                      setCurrentPage(Math.max(1, currentPage - 1))
                      setExpandedFieldId(null);
                    }}
                    disabled={currentPage === 1}
                  >
                    Previous
                  </button>
                  <div className="muted">
                    Page {currentPage} / {pages.length}
                  </div>
                  <button
                    className={`btn btn-primary btn-small ${currentPage === pages.length ? "btn-disabled" : ""}`}
                    onClick={() => {
                      setCurrentPage(Math.min(pages.length, currentPage + 1))
                      setExpandedFieldId(null);
                    }}
                    disabled={currentPage === pages.length}
                  >
                    Next
                  </button>
                </div>
              )}
            </div>
          </div >
        </div >
      </>
    );
  }

  const rootEl = document.getElementById("template-builder-root");
  if (rootEl) {
    createRoot(rootEl).render(React.createElement(TemplateBuilderApp));
  }
</script>
